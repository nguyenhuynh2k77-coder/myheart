<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<title>Trái tim 3D tương tác với nền cây cỏ</title>
<style>
  html, body { margin:0; height:100%; background:#0f0f12; }
  canvas { display:block; }
</style>
</head>
<body>
  <!-- Three.js từ CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Scene + Camera
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 40, 150);

    // Ánh sáng
    const hemi = new THREE.HemisphereLight(0xffffff, 0x202030, 0.6);
    scene.add(hemi);

    const keyLight = new THREE.SpotLight(0xffffff, 1.2, 0, Math.PI/6, 0.25, 1);
    keyLight.position.set(80, 120, 80);
    keyLight.castShadow = true;
    scene.add(keyLight);

    const fill = new THREE.PointLight(0xff4b7a, 0.6);
    fill.position.set(-60, 30, 60);
    scene.add(fill);

    // Sàn phủ cỏ
    const grassTex = new THREE.TextureLoader().load('grass.jpg');
    grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
    grassTex.repeat.set(20, 20);

    const floorMat = new THREE.MeshStandardMaterial({ map: grassTex });
    const floorGeo = new THREE.PlaneGeometry(400, 400);
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -50;
    floor.receiveShadow = true;
    scene.add(floor);

    // Background cây cỏ
    const loader = new THREE.TextureLoader();
    loader.load('grass.jpg', function(texture) {
      scene.background = texture;
    });

    // Shape trái tim
    const heartShape = new THREE.Shape();
    const x = 0, y = 0;
    heartShape.moveTo(x + 25, y + 25);
    heartShape.bezierCurveTo(x + 25, y + 25, x + 20, y, x, y);
    heartShape.bezierCurveTo(x - 30, y, x - 30, y + 35, x - 30, y + 35);
    heartShape.bezierCurveTo(x - 30, y + 55, x - 10, y + 77, x + 25, y + 95);
    heartShape.bezierCurveTo(x + 60, y + 77, x + 80, y + 55, x + 80, y + 35);
    heartShape.bezierCurveTo(x + 80, y + 35, x + 80, y, x + 50, y);
    heartShape.bezierCurveTo(x + 35, y, x + 25, y + 25, x + 25, y + 25);

    const extrudeSettings = {
      steps: 2,
      depth: 18,
      bevelEnabled: true,
      bevelThickness: 4,
      bevelSize: 3,
      bevelSegments: 2
    };

    const heartGeo = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
    heartGeo.center();

    const heartMat = new THREE.MeshPhysicalMaterial({
      color: 0xff3b6a,
      roughness: 0.35,
      metalness: 0.2,
      clearcoat: 0.6,
      clearcoatRoughness: 0.2
    });

    const heart = new THREE.Mesh(heartGeo, heartMat);
    heart.castShadow = true;
    heart.rotation.x = Math.PI;
    heart.position.y = 30;
    scene.add(heart);

    // Raycaster để bắt sự kiện click
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    window.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(heart);
      if (intersects.length > 0) {
        heart.material.color.set(Math.random() * 0xffffff);
      }
    });

    // Kéo chuột để xoay trái tim
    let isDragging = false;
    let prevMouse = { x: 0, y: 0 };

    window.addEventListener('mousedown', (e) => {
      isDragging = true;
      prevMouse.x = e.clientX;
      prevMouse.y = e.clientY;
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
    });

    window.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - prevMouse.x;
        const deltaY = e.clientY - prevMouse.y;
        heart.rotation.y += deltaX * 0.01;
        heart.rotation.x += deltaY * 0.01;
        prevMouse.x = e.clientX;
        prevMouse.y = e.clientY;
      }
    });

    // Zoom bằng cuộn chuột
    window.addEventListener('wheel', (e) => {
      if (e.deltaY < 0) {
        heart.scale.multiplyScalar(1.1);
      } else {
        heart.scale.multiplyScalar(0.9);
      }
    });

    // Animation loop
    function tick() {
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    tick();

    // Resize
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
